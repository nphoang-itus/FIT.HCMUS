### **Câu 1: Lý thuyết (2 điểm)**
a) Trình bày thứ tự gọi hàm tạo (constructor) và hàm hủy (destructor) của các lớp trong một chuỗi kế thừa (ví dụ: lớp C kế thừa lớp B, lớp B kế thừa lớp A). Cho một ví dụ C++ ngắn gọn để minh họa.

b) Phân biệt mối quan hệ **IS-A (kế thừa - inheritance)** và **HAS-A (sở hữu/bao hàm - composition)** trong thiết kế hướng đối tượng. Cho ví dụ và giải thích khi nào nên ưu tiên sử dụng mỗi loại.

### **Câu 2: Đọc hiểu và Cài đặt lớp (3 điểm)**

**a) (1.5 điểm)** Cho đoạn mã nguồn C++ sau. Hãy cho biết kết quả xuất ra màn hình và giải thích chi tiết tại sao (giải thích về object lifetime, thời điểm constructor/destructor được gọi, và vai trò của biến `static`).

```cpp
#include <iostream>
#include <vector>
#include <string>

class Device {
private:
    std::string name;
    static int deviceCount; // Biến static đếm số lượng thiết bị
public:
    Device(std::string n) : name(n) {
        deviceCount++;
        std::cout << "Device " << name << " constructed. Total devices: " << deviceCount << std::endl;
    }

    ~Device() {
        deviceCount--;
        std::cout << "Device " << name << " destructed. Total devices: " << deviceCount << std::endl;
    }

    static int getDeviceCount() {
        return deviceCount;
    }
};

int Device::deviceCount = 0;

void manageDevices() {
    std::cout << "-- Entering manageDevices scope --" << std::endl;
    Device thermostat("Thermostat");
    Device* camera = new Device("Camera");
    std::cout << "Current count in function: " << Device::getDeviceCount() << std::endl;
    delete camera;
    std::cout << "-- Exiting manageDevices scope --" << std::endl;
}

int main() {
    std::cout << "Program start." << std::endl;
    Device mainHub("Main Hub");
    manageDevices();
    std::cout << "Back in main. Final count: " << Device::getDeviceCount() << std::endl;
    std::cout << "Program end." << std::endl;
    return 0;
}
```

**b) (1.5 điểm)** Cho đoạn mã trong hàm `main()` dưới đây. Hãy cài đặt lớp `SmartLight` để đoạn mã này có thể biên dịch và chạy đúng như mô tả trong các comment.

```cpp
// Yêu cầu: Cài đặt lớp SmartLight ở đây

int main() {
    // 1. Khởi tạo một đèn thông minh với tên cho trước
    SmartLight livingRoomLight("Living Room Light");

    // 2. Bật đèn và in ra trạng thái
    livingRoomLight.turnOn();
    livingRoomLight.printStatus(); // Expected output: [Living Room Light] - Status: On, Brightness: 50%, Color: White

    // 3. Thay đổi độ sáng và màu sắc. Các hàm này phải có khả năng gọi nối tiếp (method chaining)
    livingRoomLight.setBrightness(80).setColor("Yellow");
    livingRoomLight.printStatus(); // Expected output: [Living Room Light] - Status: On, Brightness: 80%, Color: Yellow

    // 4. Tắt đèn
    livingRoomLight.turnOff();
    livingRoomLight.printStatus(); // Expected output: [Living Room Light] - Status: Off, Brightness: 80%, Color: Yellow

    return 0;
}
```

### **Câu 3: Thiết kế và Cài đặt Hệ thống (5 điểm)**

Bạn được yêu cầu thiết kế một hệ thống phần mềm đơn giản để quản lý các thiết bị trong một ngôi nhà thông minh (Smart Home).

**Yêu cầu hệ thống:**
1.  Hệ thống được điều khiển bởi một bộ trung tâm (`SmartHub`).
2.  Bộ trung tâm có thể quản lý nhiều loại thiết bị khác nhau, bao gồm:
    *   **Đèn thông minh (`SmartLight`):** có các thuộc tính Bật/Tắt, Độ sáng.
    *   **Máy điều hòa (`SmartThermostat`):** có thuộc tính Bật/Tắt, Nhiệt độ.
    *   **Camera an ninh (`SecurityCamera`):** có thuộc tính Bật/Tắt, Trạng thái ghi hình (Đang ghi/Dừng).
3.  Mỗi thiết bị, dù khác loại, đều phải có một phương thức chung để báo cáo trạng thái của nó dưới dạng một chuỗi `string`.
4.  Bộ trung tâm `SmartHub` phải có khả năng:
    *   Thêm một thiết bị mới vào hệ thống.
    *   Yêu cầu tất cả các thiết bị trong hệ thống báo cáo trạng thái của chúng và in ra màn hình.

**a) (2 điểm) Vẽ sơ đồ lớp (Class Diagram)**
Hãy vẽ sơ đồ lớp UML cho hệ thống trên. Sơ đồ phải thể hiện rõ:
*   Các lớp: `SmartHub`, và các lớp cho thiết bị.
*   Lớp cơ sở trừu tượng (nếu có) và các lớp kế thừa.
*   Các thuộc tính (attributes) và phương thức (methods) quan trọng cho mỗi lớp.
*   Mối quan hệ (ví dụ: kế thừa, composition) giữa các lớp.

**b) (2 điểm) Cài đặt các lớp**
Hãy cài đặt các lớp sau bằng C++:
*   Lớp cơ sở trừu tượng `Device` với một phương thức thuần ảo `string getStatus()`.
*   Lớp cụ thể `SmartThermostat` kế thừa từ `Device`.
*   Lớp `SmartHub` có một danh sách các con trỏ `Device*` và phương thức `reportAllStatus()` để lặp qua danh sách và gọi phương thức `getStatus()` của mỗi thiết bị, thể hiện tính đa hình (polymorphism).

**c) (1 điểm) Thiết kế mở rộng**
Hệ thống hiện tại quản lý tất cả thiết bị trong một danh sách phẳng. Để dễ quản lý hơn, người dùng muốn nhóm các thiết bị theo từng phòng (ví dụ: "Phòng khách", "Phòng ngủ"). Một phòng có thể chứa nhiều thiết bị. Hơn nữa, người dùng muốn có thể yêu cầu "báo cáo trạng thái của cả một phòng", và hệ thống sẽ tự động in ra trạng thái của tất cả các thiết bị trong phòng đó.