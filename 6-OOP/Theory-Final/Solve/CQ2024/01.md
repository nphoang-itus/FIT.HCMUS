### Câu 1 
#### a) (1 điểm) Mục tiêu của việc sử dụng template là gì? Hãy cho một ví dụ minh họa cài đặt và sử dụng function template.
##### Mục tiêu:
- Lập trình tổng quát: Cho phép viết một chương trình có thể hoạt động với nhiều kiểu dữ liệu khác nhau.
- Tái sử dụng mã nguồn: Nhờ tính lập trình tổng quát đã nói ở trên, template có thể sử dụng để định nghĩa thêm nhiều kiểu dữ liệu khác mà do người lập trình tự định nghĩa không chỉ là kiểu dữ liệu nguyên thuỷ (int, float, double,...)

##### Ví dụ minh hoạ về function template
```cpp
// Cài đặt hàm swap dùng template
template <class T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

// Sử dụng function template đã được cài đặt ở trên
int main() {
    // Kiểu dữ liệu int
    int a = 10, b = 12;
    std::cout << "a=" << a << ", " << "b=" << b << "\n"; // Xuất ra "a=10, b=12"
    swap<int>(a, b);
    std::cout << a << " " << b << "\n"; // Xuất ra "a=12, b=10"

    // Kiểu dữ liệu float
    float a = 10.12, b = 12.14;
    std::cout << "a=" << a << ", " << "b=" << b << "\n"; // Xuất ra "a=10.12, b=12.14"
    swap<float>(a, b);
    std::cout << a << " " << b << "\n"; // Xuất ra "a=12.14, b=10.12"

    return 0;
}
```
Như ví dụ trên thì chỉ cần cài đặt 1 hàm swap sử dụng template có thể sử dụng cho cả kiểu int và float (và nhiều kiểu dữ liệu khác nếu được gọi trong chương trình)

#### b) (1 điểm) Hãy phân biệt hàm ảo (virtual function) và hàm thuần ảo (pure virtual function). Cho ví dụ minh họa. Tại sao hàm ảo quan trọng cho việc kế thừa trong lập trình hướng đối tượng?
##### Virtual function:
- Khai báo: sử dụng từ khoá `virtual` trước khai báo hàm.
- Cho phép các class con kế thừa tự định nghĩa (hoặc không) các phương thức riêng cho mình, tạo nên tính đa hình.
- Ở class cha thì nếu như hàm ảo được khai báo và cài đặt thì đây sẽ là cài đặt mặc định cho các class con kế thừa.
- Hỗ trợ đa hình động, tức là gọi hàm ảo thông qua con trỏ hoặc tham chiếu tới class cha thì phiên bản hàm thực tế tức lớp con tương ứng sẽ được gọi tại thời điểm chạy.
- Có thể tạo đối tượng từ lớp có chứa hàm ảo (ko chứa hàm thuần ảo)
- Ví dụ:
```cpp
class Animal {
public:
    // virtual function
    virtual void sleep() const {
        std::cout << "Animal is sleeping\n";
    }
};

class Dog : public Animal {
public:
    // Đa hình với override
    void sleep() const override {
        std::cout << "Dog is sleeping\n";
    }
};

class Cat : public Animal {
public:
    // Đa hình với override
    void sleep() const override {
        std::cout << "Cat is sleeping\n";
    }
};

int main() {
    Animal* animal = new Animal; // Vẫn khởi tạo được bình thường
    Animal* dog = new Dog;
    Animal* cat = new Cat;

    animal->sleep(); // Animal is sleeping
    dog->sleep(); // Dog is sleeping
    cat->sleep(); // Cat is sleeping

    return 0;
}
```

##### Pure virtual function
- Khai báo: sử dụng từ khoá `virtual` trước hàm và thêm `= 0` sau hàm.
- Ở class cha sử dụng pure virtual sẽ khai báo như một interface tức không được cài đặt tại chính class cha mà bắt các class con kế thừa phải cài đặt (Nếu không cài đặt đủ pure virtual thì chương trình sẽ báo lỗi).
- Một class có chứa ít nhất 1 pure virtual function sẽ được gọi là abstract class, tức không tạo được đối tượng trực tiếp từ loại class này.
- Ví dụ:
```cpp
class IShape {
public:
    virtual float area() = 0;
    virtual float perimeter() = 0;
}

class Rectangle : public IShape {
private:
    float a, b;
public:
    float area() override {
        return a * b;
    }

    float perimeter() override {
        return 2 * (a + b);
    }
}

class Square : public IShape {
private:
    float a;
public:
    float area() override {
        return a * b;
    }

    // Không khai báo đủ pure virtual của class cha sẽ báo lỗi khi sử dụng Square
}

int main() {
    IShape* shape = new IShape; // Báo lỗi vì IShape là Abstract Class

    IShape* rec = new Rectangle;
    std::cout << rec->area() << "\n"; // Tính đúng giá trị diện tích của hình vuông

    return 0;
}
```